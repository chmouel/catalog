apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: git-clone
spec:
  workspaces:
  - name: output
    description: The git repo will be cloned onto the volume backing this workspace
  inputs:
    params:
    - name: url
      description: git url to clone
      type: string
    - name: revision
      description: git revision to checkout (branch, tag, sha, refâ€¦)
      type: string
      default: master
    - name: submodules
      description: defines if the resource should initialize and fetch the submodules
      type: string
      default: "true"
    - name: depth
      description: performs a shallow clone where only the most recent commit(s) will be fetched
      type: string
      default: "1"
    - name: sslVerify
      description: defines if http.sslVerify should be set to true or false in the global git config
      type: string
      default: "true"
    - name: subdirectory
      description: subdirectory inside the "output" workspace to clone the git repo into
      type: string
      default: "src"
    - name: deleteExisting
      description: clean out the contents of the repo's destination directory (if it already exists) before trying to clone the repo there
      type: string
      default: "false"
  results:
  - name: commit
    description: The precise commit SHA that was fetched by this Task
  steps:
  - name: clone
    image: alpine/git:latest
    script: |
      #!/usr/bin/env sh
      # Most errors handling are handled by the set -eux
      set -eux
      CHECKOUT_DIR="$(workspaces.output.path)/$(inputs.params.subdirectory)"
      URL="$(inputs.params.url)"
      REVISION="$(inputs.params.revision)"
      SUBMODULES="$(inputs.params.submodules)"
      SSLVERIFY="$(inputs.params.sslVerify)"
      DEPTH="$(inputs.params.depth)"

      [[ "$(inputs.params.deleteExisting)" == "true" && -d ${CHECKOUT_DIR} ]] && {
        find ${CHECKOUT_DIR}/|grep -v "^${CHECKOUT_DIR}/$"|xargs  rm -rf
      }

      # https://git.io/JvBCV
      ensureHomeEnv() {
          local realhomedir=$(getent passwd $(whoami)|cut -f6 -d:)
          if [[ ! -d ${realhomedir} ]];then
              mkdir -p ${realhomedir}
          fi

          if [[ ${realhomedir} == ${HOME} ]];then
              return
          fi

          if [[ ! -e ${realhomedir}/.ssh && -w ${realhomedir}/.ssh ]];then
              ln -svf ${HOME}/.ssh ${realhomedir}/.ssh
          fi
      }

      # https://git.io/JvBCr
      fetch() {
          local revision=${REVISION:-master}
          [[ -n ${CHECKOUT_DIR} ]] && {
            mkdir -p ${CHECKOUT_DIR}
            cd ${CHECKOUT_DIR}
          }

          git init .

          trimmedURL=$(echo ${URL}|sed -e 's/^[ ]*//' -e 's/[ ]*$//')
          git remote add origin ${trimmedURL}

          git config http.sslVerify ${SSLVERIFY}

          fetchArgs="fetch"
          if [[ ${DEPTH} > 0 ]];then
              fetchArgs="${fetchArgs} --tags  --depth=${DEPTH}"
          fi

          # Translating original go code from https://git.io/JvEtG
          # original comment: Fetch can fail if an old commitid was used so try
          # git pull, performing regardless of error as no guarantee that the
          # same error is returned by all git servers gitlab, github etc...
          if git ${fetchArgs} && git reset --hard ${revision};then
             true
          else
              git reset --hard FETCH_HEAD
          fi

          if [[ ${SUBMODULES} == "true" || ${SUBMODULES} == "yes" ]];then
              git submodule init
              git submodule update --recursive
              git submodule status
          fi

          echo "Successfully cloned ${trimmedURL} @ ${revision} in path $(readlink -f .)"
      }

      ensureHomeEnv
      fetch

      git rev-parse HEAD | tr -d '\n' > "$(results.commit.path)"
